import{_ as s}from"./index-Dw3yH8Lc.js";class a{constructor(){this.room=null,this.isConnected=!1,this.config={appId:"pentagram-foo-v1",relayRedundancy:5,relayUrls:["wss://tracker.webtorrent.dev","wss://tracker.openwebtorrent.com","wss://tracker.files.fm:7073/announce","wss://tracker.btorrent.xyz"],rtcConfig:{iceServers:[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:global.stun.twilio.com:3478"},{urls:"stun:stun1.l.google.com:19302"}]}},this.onPeerJoinCallback=null,this.onPeerLeaveCallback=null,this.onConnectionStatusCallback=null,this.trystero=null,this.selfId=null}async init(){if(!this.trystero)try{const o=await s(()=>import("https://cdn.jsdelivr.net/npm/trystero@0.21.6/torrent/+esm"),[]);this.trystero=o,this.selfId=o.selfId,console.log("Trystero BitTorrent strategy initialized"),console.log("Self ID:",this.selfId),console.log("Available methods:",Object.keys(o))}catch(o){throw console.error("Failed to initialize Trystero:",o),new Error("P2P library initialization failed")}}async joinRoom(o,e=null,r=null){await this.init(),this.room&&(console.warn("Already in a room, leaving first"),this.leaveRoom());try{const t={...this.config,password:e||null};return console.log(`Joining room: ${o}`),console.log("Config:",{...t,password:e?"[HIDDEN]":null}),this.room=this.trystero.joinRoom(t,o),this.setupRoomEventHandlers(),this.isConnected=!0,console.log("Room joined successfully"),this.onConnectionStatusCallback&&this.onConnectionStatusCallback("connected"),this.room}catch(t){throw console.error("Failed to join room:",t),this.isConnected=!1,this.onConnectionStatusCallback&&this.onConnectionStatusCallback("failed"),t}}setupRoomEventHandlers(){this.room&&(this.room.onPeerJoin(async o=>{console.log(`Peer joined: ${o}`);try{const e=await this.room.ping(o);console.log(`P2P latency to ${o}: ${e}ms`)}catch(e){console.warn(`Could not ping ${o}:`,e)}this.onPeerJoinCallback&&this.onPeerJoinCallback(o)}),this.room.onPeerLeave(o=>{console.log(`Peer left: ${o}`),this.removePeerAudio(o),this.onPeerLeaveCallback&&this.onPeerLeaveCallback(o)}),this.room.onPeerStream((o,e,r)=>{console.log(`Received stream from ${e}:`,r);try{r?.type==="audio"&&o.getAudioTracks().length>0&&this.handleIncomingAudioStream(o,e,r)}catch(t){console.error("Error handling peer stream:",t)}}),console.log("Room event handlers setup complete"))}handleIncomingAudioStream(o,e,r){console.log(`Handling audio stream from ${r?.username||e}`);try{const t=new Audio;if(t.srcObject=o,t.autoplay=!0,t.controls=!1,t.volume=1,this.peerAudioElements||(this.peerAudioElements=new Map),this.peerAudioElements.has(e)){const n=this.peerAudioElements.get(e);n.srcObject=null,n.remove()}this.peerAudioElements.set(e,t),o.addEventListener("ended",()=>{console.log(`Audio stream ended for ${e}`),this.removePeerAudio(e)}),o.getAudioTracks().forEach(n=>{n.addEventListener("ended",()=>{console.log(`Audio track ended for ${e}`),this.removePeerAudio(e)})}),console.log(`Audio playback started for ${r?.username||e}`)}catch(t){console.error("Failed to setup audio playback:",t)}}removePeerAudio(o){if(this.peerAudioElements&&this.peerAudioElements.has(o)){const e=this.peerAudioElements.get(o);e.srcObject=null,e.remove(),this.peerAudioElements.delete(o),console.log(`Removed audio playback for ${o}`)}}makeAction(o){if(!this.room)throw new Error("No room available");return console.log(`Creating action: ${o}`),this.room.makeAction(o)}leaveRoom(){if(this.room){console.log("Leaving room...");try{this.room.leave(),this.room=null,this.isConnected=!1,this.onConnectionStatusCallback&&this.onConnectionStatusCallback("disconnected"),console.log("Room left successfully")}catch(o){console.error("Error leaving room:",o)}}}getPeers(){if(!this.room)return new Map;try{return this.room.getPeers()}catch(o){return console.warn("Could not get peers:",o),new Map}}getTrackerStatus(){if(!this.trystero)return[];try{const o=this.trystero.getRelaySockets?.();return o?Object.entries(o).map(([e,r])=>({url:e,readyState:r.readyState,connected:r.readyState===WebSocket.OPEN})):[]}catch(o){return console.warn("Could not get tracker status:",o),[]}}async pingPeer(o){if(!this.room)throw new Error("No room available");try{return await this.room.ping(o)}catch(e){return console.warn(`Failed to ping ${o}:`,e),null}}addStream(o,e=null,r=null){if(!this.room)throw new Error("No room available");try{this.room.addStream(o,e,r),console.log("Audio stream added")}catch(t){throw console.error("Failed to add stream:",t),t}}removeStream(o,e=null){if(this.room)try{this.room.removeStream(o,e),console.log("Audio stream removed")}catch(r){console.error("Failed to remove stream:",r)}}onPeerJoin(o){this.onPeerJoinCallback=o}onPeerLeave(o){this.onPeerLeaveCallback=o}onConnectionStatus(o){this.onConnectionStatusCallback=o}getSelfId(){return this.selfId}isRoomConnected(){return this.isConnected&&this.room!==null}getConnectionInfo(){return!this.isConnected||!this.room?{connected:!1,peers:0,trackers:[]}:{connected:!0,selfId:this.selfId,peers:this.getPeers().size,trackers:this.getTrackerStatus()}}}export{a as RoomManager};
