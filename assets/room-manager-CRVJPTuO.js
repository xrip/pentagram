import{_ as s}from"./index-B17bKV0t.js";class a{constructor(){this.room=null,this.isConnected=!1,this.wakeLock=null,this.config={appId:"pentagram-foo-v1",relayUrls:["wss://tracker.webtorrent.dev","wss://tracker.openwebtorrent.com","wss://tracker.ghostchu-services.top/announce","wss://tracker.files.fm:7073/announce","wss://tracker.btorrent.xyz"],rtcConfig:{iceServers:[{urls:"stun:global.stun.twilio.com:3478"},{urls:"stun.services.mozilla.com:3478"},{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}]},turnConfig:{urls:["turn:relay1.expressturn.com:3480"],username:"000000002071633131",credential:"ca0MzQPfNpAFRA76TklRoOndCQQ="}},this.onPeerJoinCallback=null,this.onPeerLeaveCallback=null,this.onConnectionStatusCallback=null,this.trystero=null,this.selfId=null}async init(){if(!this.trystero)try{const e=await s(()=>import("https://cdn.jsdelivr.net/npm/trystero@0.21.6/torrent/+esm"),[]);this.trystero=e,this.selfId=e.selfId,console.log("Trystero BitTorrent strategy initialized"),console.log("Self ID:",this.selfId),console.log("Available methods:",Object.keys(e))}catch(e){throw console.error("Failed to initialize Trystero:",e),new Error("P2P library initialization failed")}}async joinRoom(e,o=null,r=null){await this.init(),this.room&&(console.warn("Already in a room, leaving first"),this.leaveRoom());try{const t={...this.config,password:o||null};return console.log(`Joining room: ${e}`),console.log("Config:",{...t,password:o?"[HIDDEN]":null}),this.room=this.trystero.joinRoom(t,e),this.setupRoomEventHandlers(),this.isConnected=!0,console.log("Room joined successfully"),this.requestWakeLock(),this.onConnectionStatusCallback&&this.onConnectionStatusCallback("connected"),this.room}catch(t){throw console.error("Failed to join room:",t),this.isConnected=!1,this.onConnectionStatusCallback&&this.onConnectionStatusCallback("failed"),t}}setupRoomEventHandlers(){this.room&&(this.room.onPeerJoin(async e=>{console.log(`Peer joined: ${e}`);try{const o=await this.room.ping(e);console.log(`P2P latency to ${e}: ${o}ms`)}catch(o){console.warn(`Could not ping ${e}:`,o)}this.onPeerJoinCallback&&this.onPeerJoinCallback(e)}),this.room.onPeerLeave(e=>{console.log(`Peer left: ${e}`),this.removePeerAudio(e),this.onPeerLeaveCallback&&this.onPeerLeaveCallback(e)}),this.room.onPeerStream((e,o,r)=>{console.log(`Received stream from ${o}:`,r);try{r?.type==="audio"&&e.getAudioTracks().length>0&&this.handleIncomingAudioStream(e,o,r)}catch(t){console.error("Error handling peer stream:",t)}}),console.log("Room event handlers setup complete"))}handleIncomingAudioStream(e,o,r){console.log(`Handling audio stream from ${r?.username||o}`);try{const t=new Audio;if(t.srcObject=e,t.autoplay=!0,t.controls=!1,t.volume=1,this.peerAudioElements||(this.peerAudioElements=new Map),this.peerAudioElements.has(o)){const n=this.peerAudioElements.get(o);n.srcObject=null,n.remove()}this.peerAudioElements.set(o,t),e.addEventListener("ended",()=>{console.log(`Audio stream ended for ${o}`),this.removePeerAudio(o)}),e.getAudioTracks().forEach(n=>{n.addEventListener("ended",()=>{console.log(`Audio track ended for ${o}`),this.removePeerAudio(o)})}),console.log(`Audio playback started for ${r?.username||o}`)}catch(t){console.error("Failed to setup audio playback:",t)}}removePeerAudio(e){if(this.peerAudioElements&&this.peerAudioElements.has(e)){const o=this.peerAudioElements.get(e);o.srcObject=null,o.remove(),this.peerAudioElements.delete(e),console.log(`Removed audio playback for ${e}`)}}makeAction(e){if(!this.room)throw new Error("No room available");return console.log(`Creating action: ${e}`),this.room.makeAction(e)}leaveRoom(){if(this.room){console.log("Leaving room...");try{this.room.leave(),this.room=null,this.isConnected=!1,this.releaseWakeLock(),this.onConnectionStatusCallback&&this.onConnectionStatusCallback("disconnected"),console.log("Room left successfully")}catch(e){console.error("Error leaving room:",e)}}}getPeers(){if(!this.room)return new Map;try{return this.room.getPeers()}catch(e){return console.warn("Could not get peers:",e),new Map}}getTrackerStatus(){if(!this.trystero)return[];try{const e=this.trystero.getRelaySockets?.();return e?Object.entries(e).map(([o,r])=>({url:o,readyState:r.readyState,connected:r.readyState===WebSocket.OPEN})):[]}catch(e){return console.warn("Could not get tracker status:",e),[]}}async pingPeer(e){if(!this.room)throw new Error("No room available");try{return await this.room.ping(e)}catch(o){return console.warn(`Failed to ping ${e}:`,o),null}}addStream(e,o=null,r=null){if(!this.room)throw new Error("No room available");try{this.room.addStream(e,o,r),console.log("Audio stream added")}catch(t){throw console.error("Failed to add stream:",t),t}}removeStream(e,o=null){if(this.room)try{this.room.removeStream(e,o),console.log("Audio stream removed")}catch(r){console.error("Failed to remove stream:",r)}}onPeerJoin(e){this.onPeerJoinCallback=e}onPeerLeave(e){this.onPeerLeaveCallback=e}onConnectionStatus(e){this.onConnectionStatusCallback=e}getSelfId(){return this.selfId}isRoomConnected(){return this.isConnected&&this.room!==null}getConnectionInfo(){return!this.isConnected||!this.room?{connected:!1,peers:0,trackers:[]}:{connected:!0,selfId:this.selfId,peers:this.getPeers().size,trackers:this.getTrackerStatus()}}async requestWakeLock(){if("wakeLock"in navigator)try{this.wakeLock=await navigator.wakeLock.request("screen"),console.log("Screen wake lock acquired"),this.wakeLock.addEventListener("release",()=>{console.log("Screen wake lock released")})}catch(e){console.error(`${e.name}, ${e.message}`)}else console.warn("Wake Lock API not supported.")}async releaseWakeLock(){this.wakeLock!==null&&(await this.wakeLock.release(),this.wakeLock=null)}}export{a as RoomManager};
