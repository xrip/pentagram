import{_ as r}from"./index-C88XtY74.js";class a{constructor(){this.room=null,this.isConnected=!1,this.wakeLock=null,this.connectionHealthTimer=null,this.reconnectionAttempts=0,this.maxReconnectionAttempts=5,this.reconnectionDelay=2e3,this.maxReconnectionDelay=3e4,this.isReconnecting=!1,this.lastConnectedTime=null,this.connectionStable=!1,this.stableConnectionTimer=null,this.peerHealthChecks=new Map,this.peerHealthTimer=null,this.peerHealthInterval=15e3,this.peerTimeoutThreshold=3e4,this.lastRoomConfig=null,this.config={appId:"pentagram-foo-v1",relayUrls:["wss://tracker.webtorrent.dev","wss://tracker.openwebtorrent.com","wss://tracker.ghostchu-services.top/announce","wss://tracker.files.fm:7073/announce","wss://tracker.btorrent.xyz"],rtcConfig:{iceServers:[{urls:"stun:global.stun.twilio.com:3478"},{urls:"stun:stun.services.mozilla.com:3478"},{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"},{urls:"turn:relay1.expressturn.com:3480",username:"000000002071633131",credential:"ca0MzQPfNpAFRA76TklRoOndCQQ="}]}},this.onPeerJoinCallback=null,this.onPeerLeaveCallback=null,this.onConnectionStatusCallback=null,this.trystero=null,this.selfId=null}async init(){if(!this.trystero)try{const e=await r(()=>import("https://cdn.jsdelivr.net/npm/trystero@0.21.6/torrent/+esm"),[]);this.trystero=e,this.selfId=e.selfId,console.log("Trystero BitTorrent strategy initialized"),console.log("Self ID:",this.selfId),console.log("Available methods:",Object.keys(e))}catch(e){throw console.error("Failed to initialize Trystero:",e),new Error("P2P library initialization failed")}}async joinRoom(e,t=null,n=null){await this.init(),this.room&&!this.isReconnecting&&(console.warn("Already in a room, leaving first"),this.leaveRoom());try{const o={...this.config,password:t||null};return this.lastRoomConfig={roomId:e,password:t,onError:n},console.log(`${this.isReconnecting?"Reconnecting to":"Joining"} room: ${e}`),console.log("Config:",{...o,password:t?"[HIDDEN]":null}),this.room=this.trystero.joinRoom(o,e),this.setupRoomEventHandlers(),this.isConnected=!0,this.lastConnectedTime=Date.now(),this.reconnectionAttempts=0,this.isReconnecting=!1,console.log(`Room ${this.isReconnecting?"reconnected":"joined"} successfully`),this.requestWakeLock(),this.startConnectionHealthMonitoring(),this.startPeerHealthMonitoring(),this.stableConnectionTimer=setTimeout(()=>{this.connectionStable=!0,console.log("Connection marked as stable")},1e4),this.onConnectionStatusCallback&&this.onConnectionStatusCallback("connected"),this.room}catch(o){throw console.error("Failed to join room:",o),this.isConnected=!1,this.isReconnecting=!1,this.onConnectionStatusCallback&&this.onConnectionStatusCallback("failed"),(this.connectionStable||this.reconnectionAttempts>0)&&this.scheduleReconnection(),o}}setupRoomEventHandlers(){this.room&&(this.room.onPeerJoin(async e=>{console.log(`Peer joined: ${e}`),this.peerHealthChecks.set(e,Date.now());try{const t=await this.room.ping(e);console.log(`P2P latency to ${e}: ${t}ms`),this.peerHealthChecks.set(e,Date.now())}catch(t){console.warn(`Could not ping ${e}:`,t)}this.onPeerJoinCallback&&this.onPeerJoinCallback(e)}),this.room.onPeerLeave(e=>{console.log(`Peer left: ${e}`),this.peerHealthChecks.delete(e),this.removePeerAudio(e),this.onPeerLeaveCallback&&this.onPeerLeaveCallback(e)}),this.room.onPeerStream((e,t,n)=>{console.log(`Received stream from ${t}:`,n);try{n?.type==="audio"&&e.getAudioTracks().length>0&&this.handleIncomingAudioStream(e,t,n)}catch(o){console.error("Error handling peer stream:",o)}}),console.log("Room event handlers setup complete"))}handleIncomingAudioStream(e,t,n){console.log(`Handling audio stream from ${n?.username||t}`);try{const o=new Audio;if(o.srcObject=e,o.autoplay=!0,o.controls=!1,o.volume=1,this.peerAudioElements||(this.peerAudioElements=new Map),this.peerAudioElements.has(t)){const i=this.peerAudioElements.get(t);i.srcObject=null,i.remove()}this.peerAudioElements.set(t,o),e.addEventListener("ended",()=>{console.log(`Audio stream ended for ${t}`),this.removePeerAudio(t)}),e.getAudioTracks().forEach(i=>{i.addEventListener("ended",()=>{console.log(`Audio track ended for ${t}`),this.removePeerAudio(t)})}),console.log(`Audio playback started for ${n?.username||t}`)}catch(o){console.error("Failed to setup audio playback:",o)}}removePeerAudio(e){if(this.peerAudioElements&&this.peerAudioElements.has(e)){const t=this.peerAudioElements.get(e);t.srcObject=null,t.remove(),this.peerAudioElements.delete(e),console.log(`Removed audio playback for ${e}`)}}makeAction(e){if(!this.room)throw new Error("No room available");return console.log(`Creating action: ${e}`),this.room.makeAction(e)}leaveRoom(){if(this.room){console.log("Leaving room...");try{this.room.leave(),this.room=null,this.isConnected=!1,this.connectionStable=!1,this.isReconnecting=!1,this.lastRoomConfig=null,this.releaseWakeLock(),this.stopConnectionHealthMonitoring(),this.stopPeerHealthMonitoring(),this.peerHealthChecks.clear(),this.stableConnectionTimer&&(clearTimeout(this.stableConnectionTimer),this.stableConnectionTimer=null),this.onConnectionStatusCallback&&this.onConnectionStatusCallback("disconnected"),console.log("Room left successfully")}catch(e){console.error("Error leaving room:",e)}}}getPeers(){if(!this.room)return new Map;try{return this.room.getPeers()}catch(e){return console.warn("Could not get peers:",e),new Map}}getTrackerStatus(){if(!this.trystero)return[];try{const e=this.trystero.getRelaySockets?.();return e?Object.entries(e).map(([t,n])=>({url:t,readyState:n.readyState,connected:n.readyState===WebSocket.OPEN})):[]}catch(e){return console.warn("Could not get tracker status:",e),[]}}async pingPeer(e){if(!this.room)throw new Error("No room available");try{return await this.room.ping(e)}catch(t){return console.warn(`Failed to ping ${e}:`,t),null}}addStream(e,t=null,n=null){if(!this.room)throw new Error("No room available");try{this.room.addStream(e,t,n),console.log("Audio stream added")}catch(o){throw console.error("Failed to add stream:",o),o}}removeStream(e,t=null){if(this.room)try{this.room.removeStream(e,t),console.log("Audio stream removed")}catch(n){console.error("Failed to remove stream:",n)}}onPeerJoin(e){this.onPeerJoinCallback=e}onPeerLeave(e){this.onPeerLeaveCallback=e}onConnectionStatus(e){this.onConnectionStatusCallback=e}onReconnected(e){this.onReconnectedCallback=e}getSelfId(){return this.selfId}isRoomConnected(){return this.isConnected&&this.room!==null}getConnectionInfo(){return!this.isConnected||!this.room?{connected:!1,peers:0,trackers:[]}:{connected:!0,selfId:this.selfId,peers:this.getPeers().size,trackers:this.getTrackerStatus()}}async requestWakeLock(){if("wakeLock"in navigator)try{this.wakeLock=await navigator.wakeLock.request("screen"),console.log("Screen wake lock acquired"),this.wakeLock.addEventListener("release",()=>{console.log("Screen wake lock released")})}catch(e){console.error(`${e.name}, ${e.message}`)}else console.warn("Wake Lock API not supported.")}async releaseWakeLock(){this.wakeLock!==null&&(await this.wakeLock.release(),this.wakeLock=null)}startConnectionHealthMonitoring(){this.stopConnectionHealthMonitoring(),this.connectionHealthTimer=setInterval(async()=>{await this.checkConnectionHealth()},1e4),console.log("Connection health monitoring started")}stopConnectionHealthMonitoring(){this.connectionHealthTimer&&(clearInterval(this.connectionHealthTimer),this.connectionHealthTimer=null,console.log("Connection health monitoring stopped"))}async checkConnectionHealth(){if(!(!this.isConnected||!this.room))try{this.getTrackerStatus().filter(o=>o.connected).length===0&&(console.warn("No tracker connections available, connection may be unstable"),this.connectionStable&&(console.warn("All tracker connections lost, scheduling reconnection"),this.handleConnectionLoss()));const n=this.getPeers();if(n.size>0){const o=Array.from(n.keys())[0];try{await this.room.ping(o,5e3)}catch{console.warn(`Failed to ping peer ${o}, connection may be unstable`)}}}catch(e){console.warn("Connection health check failed:",e),this.connectionStable&&this.handleConnectionLoss()}}handleConnectionLoss(){this.isReconnecting||(console.log("Connection loss detected, initiating reconnection process"),this.isConnected=!1,this.connectionStable=!1,this.onConnectionStatusCallback&&this.onConnectionStatusCallback("reconnecting"),this.scheduleReconnection())}scheduleReconnection(){if(this.isReconnecting||!this.lastRoomConfig)return;if(this.reconnectionAttempts>=this.maxReconnectionAttempts){console.error(`Max reconnection attempts (${this.maxReconnectionAttempts}) reached`),this.onConnectionStatusCallback&&this.onConnectionStatusCallback("failed");return}this.reconnectionAttempts++,this.isReconnecting=!0;const e=Math.min(this.reconnectionDelay*Math.pow(1.5,this.reconnectionAttempts-1),this.maxReconnectionDelay);console.log(`Scheduling reconnection attempt ${this.reconnectionAttempts}/${this.maxReconnectionAttempts} in ${e}ms`),setTimeout(async()=>{if(!(!this.isReconnecting||!this.lastRoomConfig))try{if(console.log(`Reconnection attempt ${this.reconnectionAttempts}/${this.maxReconnectionAttempts}`),this.room){try{this.room.leave()}catch(i){console.warn("Error leaving room during reconnection:",i)}this.room=null}const{roomId:t,password:n,onError:o}=this.lastRoomConfig;await this.joinRoom(t,n,o),this.onReconnectedCallback&&this.onReconnectedCallback()}catch(t){console.error(`Reconnection attempt ${this.reconnectionAttempts} failed:`,t),this.scheduleReconnection()}},e)}startPeerHealthMonitoring(){this.stopPeerHealthMonitoring(),this.peerHealthTimer=setInterval(async()=>{await this.checkPeerHealth()},this.peerHealthInterval),console.log("Peer health monitoring started")}stopPeerHealthMonitoring(){this.peerHealthTimer&&(clearInterval(this.peerHealthTimer),this.peerHealthTimer=null,console.log("Peer health monitoring stopped"))}async checkPeerHealth(){if(!this.isConnected||!this.room)return;const e=Date.now(),t=Array.from(this.peerHealthChecks.entries());for(const[n,o]of t){const i=e-o;if(i>this.peerTimeoutThreshold){console.warn(`Peer ${n} hasn't responded in ${i}ms, removing from health checks`),this.peerHealthChecks.delete(n);continue}try{await this.room.ping(n,1e4)!==null&&this.peerHealthChecks.set(n,e)}catch(s){console.warn(`Peer ${n} health check failed:`,s)}}}getConnectionStatus(){return this.isReconnecting?"reconnecting":this.isConnected?this.connectionStable?"stable":"connecting":"disconnected"}async forceReconnection(){if(!this.lastRoomConfig)throw new Error("No room configuration available for reconnection");console.log("Force reconnection initiated"),this.reconnectionAttempts=0,this.handleConnectionLoss()}}export{a as RoomManager};
