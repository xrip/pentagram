import{_ as c}from"./index-CM9J9nCn.js";class h{constructor(){this.room=null,this.isConnected=!1,this.wakeLock=null,this.connectionHealthTimer=null,this.reconnectionAttempts=0,this.maxReconnectionAttempts=5,this.reconnectionDelay=2e3,this.maxReconnectionDelay=3e4,this.reconnectionTimeout=null,this.isReconnecting=!1,this.lastConnectedTime=null,this.connectionStable=!1,this.stableConnectionTimer=null,this.peerHealthChecks=new Map,this.peerHealthTimer=null,this.peerHealthInterval=15e3,this.peerTimeoutThreshold=3e4,this.lastRoomConfig=null,this.username=null,this.identity=null,this.sendUserInfo=null,this.config={appId:"pentagram-foo-v1",relayUrls:["wss://tracker.webtorrent.dev","wss://tracker.openwebtorrent.com","wss://tracker.ghostchu-services.top/announce","wss://tracker.files.fm:7073/announce","wss://tracker.btorrent.xyz"],relayRedundancy:3,rtcConfig:{iceServers:[{urls:"stun:global.stun.twilio.com:3478"},{urls:"stun:stun.services.mozilla.com:3478"},{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"},{urls:"turn:relay1.expressturn.com:3480",username:"000000002071633131",credential:"ca0MzQPfNpAFRA76TklRoOndCQQ="}]}},this.onPeerJoinCallback=null,this.onPeerLeaveCallback=null,this.onConnectionStatusCallback=null,this.trystero=null,this.selfId=null}async init(){if(!this.trystero)try{const e=await c(()=>import("https://cdn.jsdelivr.net/npm/trystero@0.21.6/torrent/+esm"),[]);this.trystero=e,this.selfId=e.selfId,console.log("Trystero BitTorrent strategy initialized"),console.log("Self ID:",this.selfId),console.log("Available methods:",Object.keys(e))}catch(e){throw console.error("Failed to initialize Trystero:",e),new Error("P2P library initialization failed")}}async joinRoom(e,t=null,o=null){await this.init(),this.room&&!this.isReconnecting&&(console.warn("Already in a room, leaving first"),await this.leaveRoom(),await new Promise(n=>setTimeout(n,100)));try{const n={...this.config,password:t||null};return this.lastRoomConfig={roomId:e,password:t,onError:o},console.log(`${this.isReconnecting?"Reconnecting to":"Joining"} room: ${e}`),console.log("Config:",{...n,password:t?"[HIDDEN]":null}),this.room=this.trystero.joinRoom(n,e),this.setupRoomEventHandlers(),this.isConnected=!0,this.lastConnectedTime=Date.now(),this.reconnectionAttempts=0,this.isReconnecting=!1,console.log(`Room ${this.isReconnecting?"reconnected":"joined"} successfully`),this.requestWakeLock(),this.startConnectionHealthMonitoring(),this.startPeerHealthMonitoring(),this.stableConnectionTimer=setTimeout(()=>{this.connectionStable=!0,console.log("Connection marked as stable")},1e4),this.onConnectionStatusCallback&&this.onConnectionStatusCallback("connected"),this.room}catch(n){throw console.error("Failed to join room:",n),this.isConnected=!1,this.isReconnecting=!1,this.onConnectionStatusCallback&&this.onConnectionStatusCallback("failed"),(this.connectionStable||this.reconnectionAttempts>0)&&this.scheduleReconnection(),n}}setupRoomEventHandlers(){this.room&&(this.room.onPeerJoin(async e=>{console.log(`Peer joined: ${e}`),this.peerHealthChecks.set(e,Date.now());try{const t=await this.room.ping(e);console.log(`P2P latency to ${e}: ${t}ms`),this.peerHealthChecks.set(e,Date.now())}catch(t){console.warn(`Could not ping ${e}:`,t)}this.onPeerJoinCallback&&this.onPeerJoinCallback(e)}),this.room.onPeerLeave(e=>{console.log(`Peer left: ${e}`),this.peerHealthChecks.delete(e),this.removePeerAudio(e),this.onPeerLeaveCallback&&this.onPeerLeaveCallback(e)}),this.room.onPeerStream((e,t,o)=>{console.log(`Received stream from ${t}:`,o);try{o?.type==="audio"&&e.getAudioTracks().length>0&&this.handleIncomingAudioStream(e,t,o)}catch(n){console.error("Error handling peer stream:",n)}}),console.log("Room event handlers setup complete"))}handleIncomingAudioStream(e,t,o){console.log(`Handling audio stream from ${o?.username||t}`);try{const n=new Audio;if(n.srcObject=e,n.autoplay=!0,n.controls=!1,n.volume=1,this.peerAudioElements||(this.peerAudioElements=new Map),this.peerAudioElements.has(t)){const s=this.peerAudioElements.get(t);s.srcObject=null,s.remove()}this.peerAudioElements.set(t,n),e.addEventListener("ended",()=>{console.log(`Audio stream ended for ${t}`),this.removePeerAudio(t)}),e.getAudioTracks().forEach(s=>{s.addEventListener("ended",()=>{console.log(`Audio track ended for ${t}`),this.removePeerAudio(t)})}),console.log(`Audio playback started for ${o?.username||t}`)}catch(n){console.error("Failed to setup audio playback:",n)}}removePeerAudio(e){if(this.peerAudioElements&&this.peerAudioElements.has(e)){const t=this.peerAudioElements.get(e);t.srcObject=null,t.remove(),this.peerAudioElements.delete(e),console.log(`Removed audio playback for ${e}`)}}makeAction(e){if(!this.room)throw new Error("No room available");return console.log(`Creating action: ${e}`),this.room.makeAction(e)}async leaveRoom(){if(this.room){console.log("Leaving room with full cleanup...");try{const e=this.room.getPeers();console.log(`Closing ${e.size} peer connections...`);for(const[t,o]of e)try{o.connectionState!=="closed"&&(o.close(),console.log(`Closed connection to peer: ${t}`))}catch(n){console.warn(`Error closing peer connection ${t}:`,n)}this.room.leave(),console.log("Room left successfully"),this.room=null}catch(e){console.error("Error during room cleanup:",e),this.room=null}this.isConnected=!1,this.connectionStable=!1,this.isReconnecting=!1,this.lastRoomConfig=null,this.releaseWakeLock(),this.stopConnectionHealthMonitoring(),this.stopPeerHealthMonitoring(),this.peerHealthChecks.clear(),this.stableConnectionTimer&&(clearTimeout(this.stableConnectionTimer),this.stableConnectionTimer=null),this.reconnectionTimeout&&(clearTimeout(this.reconnectionTimeout),this.reconnectionTimeout=null),this.onConnectionStatusCallback&&this.onConnectionStatusCallback("disconnected")}}getPeers(){if(!this.room)return new Map;try{return this.room.getPeers()}catch(e){return console.warn("Could not get peers:",e),new Map}}getTrackerStatus(){if(!this.trystero)return[];try{const e=this.trystero.getRelaySockets?.();return e?Object.entries(e).map(([t,o])=>({url:t,readyState:o.readyState,connected:o.readyState===WebSocket.OPEN})):[]}catch(e){return console.warn("Could not get tracker status:",e),[]}}async pingPeer(e){if(!this.room)throw new Error("No room available");try{return await this.room.ping(e)}catch(t){return console.warn(`Failed to ping ${e}:`,t),null}}addStream(e,t=null,o=null){if(!this.room)throw new Error("No room available");try{this.room.addStream(e,t,o),console.log("Audio stream added")}catch(n){throw console.error("Failed to add stream:",n),n}}removeStream(e,t=null){if(this.room)try{this.room.removeStream(e,t),console.log("Audio stream removed")}catch(o){console.error("Failed to remove stream:",o)}}onPeerJoin(e){this.onPeerJoinCallback=e}onPeerLeave(e){this.onPeerLeaveCallback=e}onConnectionStatus(e){this.onConnectionStatusCallback=e}onReconnected(e){this.onReconnectedCallback=e}setUserInfo(e,t,o){this.username=e,this.identity=t,this.sendUserInfo=o,console.log("Room manager user info set:",{username:e,hasIdentity:!!t,hasSendUserInfo:!!o})}getSelfId(){return this.selfId}isRoomConnected(){return this.isConnected&&this.room!==null}getConnectionInfo(){return!this.isConnected||!this.room?{connected:!1,peers:0,trackers:[]}:{connected:!0,selfId:this.selfId,peers:this.getPeers().size,trackers:this.getTrackerStatus()}}async requestWakeLock(){if("wakeLock"in navigator)try{this.wakeLock=await navigator.wakeLock.request("screen"),console.log("Screen wake lock acquired"),this.wakeLock.addEventListener("release",()=>{console.log("Screen wake lock released")})}catch(e){console.error(`${e.name}, ${e.message}`)}else console.warn("Wake Lock API not supported.")}async releaseWakeLock(){this.wakeLock!==null&&(await this.wakeLock.release(),this.wakeLock=null)}startConnectionHealthMonitoring(){this.stopConnectionHealthMonitoring(),this.connectionHealthTimer=setInterval(async()=>{await this.checkConnectionHealth()},1e4),console.log("Connection health monitoring started")}stopConnectionHealthMonitoring(){this.connectionHealthTimer&&(clearInterval(this.connectionHealthTimer),this.connectionHealthTimer=null,console.log("Connection health monitoring stopped"))}async checkConnectionHealth(){if(!(!this.isConnected||!this.room))try{this.getTrackerStatus().filter(n=>n.connected).length===0&&(console.warn("No tracker connections available, connection may be unstable"),this.connectionStable&&(console.warn("All tracker connections lost, scheduling reconnection"),this.handleConnectionLoss()));const o=this.getPeers();if(o.size>0){const n=Array.from(o.keys())[0];try{await this.room.ping(n,5e3)}catch{console.warn(`Failed to ping peer ${n}, connection may be unstable`)}}}catch(e){console.warn("Connection health check failed:",e),this.connectionStable&&this.handleConnectionLoss()}}async handleConnectionLoss(){this.isReconnecting||(console.log("Connection loss detected, initiating reconnection process"),this.isConnected=!1,this.connectionStable=!1,this.onConnectionStatusCallback&&this.onConnectionStatusCallback("reconnecting"),await this.scheduleReconnection())}async scheduleReconnection(){if(this.isReconnecting||!this.lastRoomConfig)return;if(this.reconnectionAttempts>=this.maxReconnectionAttempts){if(console.error(`Max reconnection attempts (${this.maxReconnectionAttempts}) reached`),this.isReconnecting=!1,this.room)try{if(this.room.getPeers){const t=this.room.getPeers();for(const[o,n]of t)try{n.connectionState!=="closed"&&n.close()}catch(s){console.warn(`Error closing peer ${o}:`,s)}}this.room.leave(),this.room=null}catch(t){console.warn("Final cleanup error:",t),this.room=null}this.onConnectionStatusCallback&&this.onConnectionStatusCallback("failed");return}this.reconnectionAttempts++,this.isReconnecting=!0;const e=Math.min(this.reconnectionDelay*Math.pow(1.5,this.reconnectionAttempts-1),this.maxReconnectionDelay);console.log(`Scheduling reconnection attempt ${this.reconnectionAttempts}/${this.maxReconnectionAttempts} in ${e}ms`),this.reconnectionTimeout&&(clearTimeout(this.reconnectionTimeout),console.log("Cleared existing reconnection timeout")),this.reconnectionTimeout=setTimeout(async()=>{if(!(!this.isReconnecting||!this.lastRoomConfig))try{if(console.log(`Reconnection attempt ${this.reconnectionAttempts}/${this.maxReconnectionAttempts}`),this.room)try{await this.leaveRoom(),await new Promise(s=>setTimeout(s,200))}catch(s){console.warn("Error leaving room during reconnection:",s),this.room=null}const{roomId:t,password:o,onError:n}=this.lastRoomConfig;await this.joinRoom(t,o,n),this.onReconnectedCallback&&this.onReconnectedCallback()}catch(t){console.error(`Reconnection attempt ${this.reconnectionAttempts} failed:`,t),await this.scheduleReconnection()}},e)}startPeerHealthMonitoring(){this.stopPeerHealthMonitoring(),this.peerHealthTimer=setInterval(async()=>{await this.checkPeerHealth()},this.peerHealthInterval),console.log("Peer health monitoring started")}stopPeerHealthMonitoring(){this.peerHealthTimer&&(clearInterval(this.peerHealthTimer),this.peerHealthTimer=null,console.log("Peer health monitoring stopped"))}async checkPeerHealth(){if(!this.isConnected||!this.room)return;const e=Date.now(),t=Array.from(this.peerHealthChecks.entries());for(const[o,n]of t){const s=e-n;if(s>this.peerTimeoutThreshold){console.warn(`Peer ${o} hasn't responded in ${s}ms, removing from health checks`),this.peerHealthChecks.delete(o);continue}try{await this.room.ping(o,1e4)!==null&&this.peerHealthChecks.set(o,e)}catch(i){console.warn(`Peer ${o} health check failed:`,i)}}}getConnectionStatus(){return this.isReconnecting?"reconnecting":this.isConnected?this.connectionStable?"stable":"connecting":"disconnected"}async forceReconnection(){if(!this.lastRoomConfig)throw new Error("No room configuration available for reconnection");console.log("Force reconnection initiated"),this.reconnectionAttempts=0,await this.handleConnectionLoss()}async forceAnnounceToTrackers(){if(!this.room){console.warn("Cannot announce: no active room");return}try{const e=this.trystero.getRelaySockets();console.log("Current tracker connections:",Object.keys(e));const t=[],o=[];for(const[n,s]of Object.entries(e))s&&s.readyState===WebSocket.OPEN?t.push(n):o.push(n);return console.log(`Connected to ${t.length} trackers:`,t),o.length>0&&console.warn(`Disconnected from ${o.length} trackers:`,o),this.sendUserInfo&&this.identity&&this.username&&(console.log("Broadcasting presence to trigger peer discovery..."),this.sendUserInfo({username:this.username,publicKey:this.identity.publicKey,joinedAt:Date.now(),announcement:!0})),{connectedTrackers:t.length,disconnectedTrackers:o.length,totalTrackers:Object.keys(e).length}}catch(e){return console.error("Failed to announce to trackers:",e),null}}getDetailedConnectionStatus(){if(!this.room||!this.trystero)return{room:!1,trackers:[],peers:0,selfId:this.selfId};try{const e=this.trystero.getRelaySockets(),t=[];for(const[i,r]of Object.entries(e))t.push({url:i,connected:r&&r.readyState===WebSocket.OPEN,readyState:r?r.readyState:"no-socket"});const o=this.getPeers();let n=0,s=[];return o&&typeof o.size=="number"?(n=o.size,s=Array.from(o.keys())):o&&typeof o=="object"&&(s=Object.keys(o),n=s.length),{room:!0,selfId:this.selfId,trackers:t,peers:n,peerIds:s,connectedTrackers:t.filter(i=>i.connected).length,totalTrackers:t.length}}catch(e){return console.error("Failed to get detailed connection status:",e),{room:!0,error:e.message,selfId:this.selfId}}}}export{h as RoomManager};
